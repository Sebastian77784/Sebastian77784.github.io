<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Costos - Unidad 3</title>
  <link rel="stylesheet" href="../img_sub/styles.css" />
</head>
<body>
  <div class="overlay">
    <div class="container">

      <h1><strong>3.2 Costos</strong></h1>
        <p>es la eficiencia y los recursos que consume el proceso de traducción y ejecución del código. Se consideran tanto los costos durante la compilación como en la ejecución del programa generado.</p>
        
        <h2>3.2.1 Costo de ejecución (memoria, registros, pilas)</h2>
        <p>El costo de ejecución se refiere a los recursos que usa el programa cuando corre en la máquina:</p>

        <p><strong>Memoria:</strong></p>
        <ul>
            <li>Se refiere al espacio requerido para almacenar variables, constantes, estructuras de datos, código y pilas de ejecución.</li>
            <li>Una mala gestión de memoria (p. ej., muchas variables locales, almacenamiento innecesario) puede incrementar el costo.</li>
        </ul>
        <p><strong>Registros:</strong></p>
        <ul>
            <li>Son pequeños espacios de almacenamiento rápido en el procesador</li>
            <li>La asignación eficiente de registros (register allocation) es crucial para mejorar la velocidad de ejecución y minimizar accesos a memoria lenta.</li>
            <li>El costo aumenta si el compilador debe usar memoria en lugar de registros debido a falta de disponibilidad.</li>
        </ul>

        <p><strong>Pilas:</strong></p>
        <ul>
            <li>La pila de ejecución guarda información de llamadas a funciones, variables locales y contextos.</li>
            <li>El costo puede aumentar por recursión profunda o por manejo ineficiente de la pila (p. ej., exceso de llamadas o variables temporales).</li>
            <li>Optimizar el uso de la pila puede mejorar el rendimiento y evitar desbordamientos.</li>
        </ul>

        <h2>3.2.2 Criterios para mejorar el código</h2>
        <p>Para reducir los costos y mejorar la eficiencia del programa generado, los compiladores aplican optimizaciones con criterios como:</p>

        <p><strong>Eliminación de código muerto:</strong></p>
        <ul>
            <li>Código que nunca se ejecuta o cuyos resultados nunca se usan.</li>
            <li>Quitar este código reduce tamaño y costo de ejecución.</li>
        </ul>
        <p><strong>Eliminación de subexpresiones comunes:</strong></p>
        <ul>
            <li>Reusar resultados calculados anteriormente en lugar de recalcular.</li>
            <li>Reduce instrucciones y uso de recursos.</li>
        </ul>

        <p><strong>Simplificación de expresiones:</strong></p>
        <ul>
            <li>Reemplazar expresiones complejas por equivalentes más simples.</li>
            <li>Por ejemplo, reemplazar x * 2 por x << 1 (desplazamiento de bits).</li>
        </ul>

        <p><strong>Asignación eficiente de registros:</strong></p>
        <ul>
            <li>Minimizar accesos a memoria cargando valores en registros.</li>
            <li>Técnicas como el algoritmo de grafos de interferencia.</li>
        </ul>

        <p><strong>Desenrollado de ciclos (loop unrolling):</strong></p>
        <ul>
            <li>Expandir manualmente el cuerpo de un ciclo para reducir overhead de control.</li>
            <li>Puede aumentar tamaño de código pero mejorar rendimiento.</li>
        </ul>
        <p><strong>Optimización de bucles:</strong></p>
        <ul>
            <li>Reorganizar instrucciones dentro del ciclo para minimizar dependencias y mejorar paralelismo.</li>
        </ul>

        <h2>3.2.3 Herramientas para el análisis del flujo de datos</h2>
        <p>
            El análisis del flujo de datos es fundamental para identificar oportunidades de optimización y detectar errores.
        </p>

        <p><strong>Análisis de flujo de control:</strong></p>
        <ul>
            <li>Determina el orden en que se ejecutan las instrucciones.</li>
            <li>Detecta caminos posibles, ciclos, puntos de entrada y salida.</li>
        </ul>

        <p><strong>Análisis de uso y definición:</strong></p>
        <ul>
            <li>Identifica dónde se definen (asignan) y usan las variables.</li>
            <li>Permite detectar variables no usadas o definir dónde se puede reusar memoria.</li>
        </ul>

        <p><strong>Análisis de alcance de variables:</strong></p>
        <ul>
            <li>Determina dónde cada variable es válida.</li>
            <li>Ayuda a optimizar la asignación de memoria.</li>
        </ul>

        <p><strong>Análisis de dependencia:</strong></p>
        <ul>
            <li>Detecta dependencias entre instrucciones que limitan paralelización o reordenamiento.</li>
        </ul>

        <p><strong>Herramientas comunes:</strong></p>
        <ul>
            <li><strong>Grafos de flujo de control (CFG - Control Flow Graph):</strong> Representan los caminos del programa.</li>
            <li><strong>Grafos de dependencia:</strong> Muestran relaciones entre instrucciones y variables.</li>
            <li><strong>Pilas de análisis semántico:</strong>Para verificar tipos, ámbitos y consistencia.</li>
        </ul>

        <p><strong>Propagación de constantes y análisis de alcance:</strong></p>
        <ul>
            <li>Detectan valores constantes a lo largo del código para optimizar y reducir instrucciones.</li>
        </ul>
        
      <a href="../../index.html" class="back-button">← Volver al índice</a>
    </div>
  </div>
</body>
</html>
