<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Registros - Unidad 4</title>
  <link rel="stylesheet" href="../img_sub/styles.css" />
</head>
<body>
  <div class="overlay">
    <div class="container">

      <h1><strong>4.1 Registros. </strong></h1>
        <p>Los registros son pequeñas unidades de almacenamiento dentro del procesador que se utilizan para guardar temporalmente datos y realizar operaciones de forma rápida. Son mucho más veloces que la memoria principal (RAM) y esenciales para la ejecución eficiente de programas.</p>
        
        <p><strong>Tipos de Registros</strong></p>
        <ul>
            En el contexto de la generación de código y optimización, se pueden distinguir varios tipos de registros:
            <li><strong>Registros de propósito general (GPR):</strong> Usados para almacenar datos temporales, operandos de operaciones aritméticas/lógicas, resultados, etc.</li>
            <li><strong>Registros de propósito específico:</strong> 
            <ul>
                <li><strong>Contador de programa (PC):</strong> Guarda la dirección de la siguiente instrucción a ejecutar.</li>
                <li><strong>Registro de estado/flags:</strong> Guarda información sobre el resultado de operaciones (signo, cero, overflow).</li>
                <li><strong>Registro acumulador:</strong> Utilizado comúnmente como operando o resultado de muchas instrucciones.</li>
                <li><strong>Registros índice y punteros:</strong>Usados para acceder a posiciones de memoria, especialmente en arreglos o estructuras.</li>
            </ul></li>
        </ul>

        <p><strong>Importancia de los registros en la generación de código</strong></p>
        <ul>
            Durante la generación de código intermedio y final, los compiladores intentan usar registros tanto como sea posible por varias razones:
            <li><strong>Velocidad:</strong> Leer y escribir en registros es mucho más rápido que en la memoria.</li>
            <li><strong>Eficiencia:</strong> El uso adecuado de registros reduce el número de accesos a memoria.</li>
            <li><strong>Optimización:</strong> La asignación inteligente de registros (register allocation) mejora el rendimiento del programa.</li>
        </ul>

        <p><strong>Asignación de registros (Register Allocation)</strong></p>
        <ul>
            Una tarea clave del compilador es asignar variables temporales y resultados a registros disponibles:
            <li>Si hay suficientes registros, el compilador puede mantener todos los valores necesarios en ellos.</li>
            <li>Si no hay suficientes registros (registro spill), algunos valores deben moverse a memoria, lo cual es más lento.</li>
        </ul>
        <p><strong>Técnicas comunes:</strong></p>
        <ul>
            <li><strong>Algoritmo de grafos de interferencia:</strong> Se crea un grafo donde los nodos son variables temporales, y se colorea con el número de registros disponibles. Si dos variables interfieren (se usan al mismo tiempo), no pueden compartir el mismo registro.</li>
            <li><strong>Asignación lineal (Lineal Scan Allocation):</strong> Técnica más rápida pero menos óptima que el grafo, usada en compiladores Just-In-Time como los de Java y JavaScript.</li>
        </ul>

        <p><strong>Ejemplo simple (código intermedio con registros)</strong></p>
        <ul>Supón la expresión:</ul>
        <div style="text-align: center; margin: 2rem 0;">
        <img src="../unidad4/img/1.png" alt="Ejemplo de árbol de expresión" style="max-width: 600px; width: 100%; border-radius:8px; box-shadow:0 4px 8px rgba(0,0,0,0.2);" />
      </div>

      <ul>Código intermedio con uso de registros:</ul>
      <div style="text-align: center; margin: 2rem 0;">
        <img src="../unidad4/img/2.png" alt="Ejemplo de árbol de expresión" style="max-width: 600px; width: 100%; border-radius:8px; box-shadow:0 4px 8px rgba(0,0,0,0.2);" />
      <li>Aquí R1 y R2 son registros que almacenan los resultados intermedios para evitar escribir en memoria después de cada operación.</li>
    </div>

    <p><strong>Consideraciones del compilador</strong></p>
        <ul>
            El compilador debe tomar en cuenta:
            <li>Número limitado de registros físicos.</li>
            <li>El tiempo de vida de cada variable.</li>
            <li>Evitar conflictos entre variables activas al mismo tiempo.</li>
            <li>Decidir qué valores guardar en registros y cuáles mover a memoria (spilling).</li>
        </ul>




      <a href="../../index.html" class="back-button">← Volver al índice</a>
    </div>
  </div>
</body>
</html>